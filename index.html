<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Diamond Obfuscator (Luau)</title>
<style>
  :root{
    --bg:#071023; --panel:#09142a; --accent:#2fb7ff; --text:#e6f7ff;
    --muted:#9fbfda; --btn:#0b84d6;
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center;
    font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;
    background:
      radial-gradient(800px 400px at -10% -10%, rgba(47,183,255,0.06), transparent 20%),
      radial-gradient(900px 500px at 110% 110%, rgba(47,183,255,0.04), transparent 20%),
      var(--bg);
    color:var(--text); padding:28px;
  }
  .wrap{ width:min(1080px,98vw) }
  header{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:14px }
  h1{
    margin:0; font-weight:800; font-size:clamp(20px,3.4vw,34px);
    background: linear-gradient(90deg,var(--accent),#8fe7ff);
    -webkit-background-clip:text; background-clip:text; color:transparent;
    text-shadow:0 6px 28px rgba(15,86,120,0.12);
  }
  .sub{ color:var(--muted); font-size:13px }
  .grid{ display:grid; gap:14px; grid-template-columns:1fr 460px }
  @media(max-width:980px){ .grid{ grid-template-columns:1fr } }
  .card{
    background:linear-gradient(180deg,var(--panel), #071225);
    border-radius:12px; padding:14px; border:1px solid rgba(255,255,255,0.03);
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
  }
  label.switch{ display:inline-flex; gap:10px; align-items:center; cursor:pointer; color:var(--muted) }
  input[type="checkbox"]{ width:18px; height:18px }
  textarea{
    width:100%; min-height:260px; resize:vertical; background:#041226; color:#dff6ff;
    border-radius:8px; border:1px solid rgba(255,255,255,0.04); padding:12px; font-family:monospace;
    font-size:13px; line-height:1.4;
  }
  .row{ display:flex; gap:10px; align-items:center; margin-top:12px; flex-wrap:wrap }
  .btn{
    background:linear-gradient(180deg,var(--btn),#0a6ab5); color:#fff; border:none; padding:10px 14px;
    border-radius:10px; font-weight:700; cursor:pointer; box-shadow:0 8px 20px rgba(11,104,170,0.18);
  }
  .btn.secondary{ background:linear-gradient(180deg,#0e2338,#071226); color:var(--muted); border:1px solid rgba(255,255,255,0.02) }
  .hint{ color:var(--muted); font-size:12px }
  pre.output{ white-space:pre-wrap; word-break:break-all; max-height:520px; overflow:auto; padding:10px; background:#021122; border-radius:8px; border:1px solid rgba(255,255,255,0.02); color:#c8f1ff; font-family:monospace; font-size:13px }
  footer{ margin-top:10px; text-align:right; color:var(--muted); font-size:12px }
  .small{ font-size:12px; color:var(--muted) }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Diamond Obfuscator</h1>
        <div class="sub">Layered, Luau-safe obfuscation (IronBrew style) — client side</div>
      </div>
      <div class="small">--[[obfed by Diamond obfuscator - ironbrew style]]</div>
    </header>

    <div class="grid">
      <!-- LEFT: INPUT -->
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Input (Luau)</strong>
          <div class="small">Paste & obfuscate locally — no server</div>
        </div>

        <textarea id="inputArea" placeholder="Paste your Luau code here... (e.g. print('hello'))"></textarea>

        <div class="row" style="margin-top:10px">
          <button class="btn" id="obfBtn">Obfuscate</button>
          <button class="btn secondary" id="exampleBtn" title="Load tiny example">Load Example</button>
          <label class="switch" title="Output single-line compact">
            <input type="checkbox" id="oneLineChk"> One Liner
          </label>
          <label class="switch" title="Also compress whitespace in inner layers">
            <input type="checkbox" id="compactInner" checked> Compact Inner
          </label>
        </div>

        <div class="row" style="margin-top:8px;align-items:center">
          <div class="hint">Layers:</div>
          <select id="layerCount" style="padding:6px;border-radius:8px;background:#081426;color:#dff6ff;border:1px solid rgba(255,255,255,0.03)">
            <option value="1">1 (fast)</option>
            <option value="2">2</option>
            <option value="3" selected>3 (recommended)</option>
            <option value="4">4</option>
            <option value="5">5 (messy)</option>
          </select>
          <div style="flex:1"></div>
          <div class="hint">Output size will increase with layers</div>
        </div>
      </div>

      <!-- RIGHT: OUTPUT -->
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Output</strong>
          <div class="small">Luau-safe — uses <code>bit32.bxor</code> + <code>loadstring</code></div>
        </div>

        <pre id="outArea" class="output" readonly></pre>

        <div class="row" style="margin-top:10px">
          <button class="btn" id="copyBtn">Copy</button>
          <button class="btn" id="downloadBtn">Download</button>
          <button class="btn secondary" id="verifyBtn" title="Quick local sanity check (won't run in Roblox here)">Verify Syntax</button>
        </div>

        <div style="margin-top:10px" class="small hint">
          This creates layered number payloads + decoder. Keep critical runtime code (render loops) as minimal as possible to avoid performance impact.
        </div>
      </div>
    </div>

    <footer>Made with care — Diamond Obfuscator (Luau) • Local only</footer>
  </div>

<script>
/* ---------- Utilities ---------- */
function rndId(len=8){
  const letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let s="";
  for(let i=0;i<len;i++) s+=letters.charAt(Math.floor(Math.random()*letters.length));
  return s;
}
function toBytesUtf8(str){
  const out=[];
  for(let i=0;i<str.length;i++){
    let c = str.charCodeAt(i);
    if(c<=0x7F) out.push(c);
    else if(c<=0x7FF){
      out.push(0xC0 | (c>>6), 0x80 | (c&0x3F));
    } else if(c>=0xD800 && c<=0xDBFF){
      const hi=c; const lo=str.charCodeAt(++i);
      const cp = (hi-0xD800)*0x400 + (lo-0xDC00) + 0x10000;
      out.push(0xF0 | (cp>>18), 0x80 | ((cp>>12)&0x3F), 0x80 | ((cp>>6)&0x3F), 0x80 | (cp&0x3F));
    } else {
      out.push(0xE0 | (c>>12), 0x80 | ((c>>6)&0x3F), 0x80 | (c&0x3F));
    }
  }
  return out;
}
function joinNums(arr){ return arr.join(","); }

/* encode a string into an array of numbers by XOR key */
function encodeNumbersFromString(str, key){
  const bytes = toBytesUtf8(str);
  const out = bytes.map(b => (b ^ key) & 0xFF);
  return out;
}

/* compress whitespace (optional) */
function compactText(s){
  return s.replace(/\s+/g," ").trim();
}

/* Build a layer that holds numeric array for given 'payloadStr' and key.
   The payloadStr is a full Lua string (previous layer text), we encode it as numbers and create
   a Luau snippet that decodes into that payload and returns it (or executes if inner-most).
*/
function buildLayerLua(payloadStr, key, opts){
  // encode payloadStr into numbers (bytes)
  const nums = encodeNumbersFromString(payloadStr, key);
  // chunking can be used for very long arrays, but we'll emit one table
  const tblName = rndId(6);
  const tmpName = rndId(6);
  const outName = rndId(5);
  const sbits = joinNums(nums);
  // Luau-safe decode code - uses bit32.bxor then string.char(table.unpack(...))
  // We'll produce a function that returns the decoded string.
  let layer =
`(function()
local ${tblName} = {${sbits}}
for i=1,#${tblName} do ${tblName}[i] = bit32.bxor(${tblName}[i], ${key}) end
local ${tmpName} = ""
for i=1,#${tblName} do ${tmpName} = ${tmpName} .. string.char(${tblName}[i]) end
return ${tmpName}
end)()`;
  if (opts && opts.compact) layer = compactText(layer);
  return layer;
}

/* create a realistic junk function block (valid Luau) */
function makeJunkBlock(){
  const fn = rndId(6);
  const a = Math.floor(Math.random()*4000)+100;
  const b = Math.floor(Math.random()*4000)+200;
  const c = Math.floor(Math.random()*100)+1;
  // Avoid using ~ operator — use arithmetic and bit32 ops if needed
  return `do local ${fn} = ${a} + ${b}; ${fn} = bit32.bxor(${fn}, ${c}); end`;
}

/* Build the final multi-layered obfuscated Luau script.
   layers: integer >=1
   oneLine: boolean -> compress final output to one line
   compactInner: boolean -> try to compact inner layer strings for smaller output
*/
function generateObfuscated(scriptText, layers=3, oneLine=false, compactInner=true){
  // Start with payload being the raw script (we may add small junk prefixes)
  // To make it more IronBrew-like, optionally add small harmless comment prefix (won't break)
  const junkComment = `--[[JUNK:${Math.random().toString(36).slice(2,10)}]]\\n`;
  let current = junkComment + scriptText;

  // We'll perform LAYER encoding iteratively: each iteration encodes the *text* of the previous layer into numbers.
  // For layer N: layerN = buildLayerLua(payload=current, key=keyN)
  // After process, the final file will be code that decodes layerN -> string (which is Lua code that decodes layerN-1 -> ... -> original script)
  const layerKeys = [];
  const layerStrings = []; // store textual representation of each layer in order (for debugging if needed)
  for(let i=0;i<layers;i++){
    const key = Math.floor(Math.random()*200)+11; // key != 0
    layerKeys.push(key);
    // create the encoded payload representing the *entire text* of the previous 'current'
    const encodedLayer = buildLayerLua(current, key, {compact: compactInner});
    // Now we want the next step to treat 'encodedLayer' as a string that will be executed to produce the previous content.
    // However buildLayerLua returns a JS string representing "(function() ... return tmp end)()"
    // For the next iteration we need the textual representation (Lua source) of encodedLayer as a string.
    // So current = encodedLayer (which is Lua), and then next iteration encodes that Lua text.
    current = encodedLayer;
    layerStrings.push(current);
  }

  // After building layers, 'current' holds the outermost Lua text that evaluates to the previous (until inner-most)
  // We now need to create a runner that executes decoding steps in Roblox Luau.
  // But the approach used above produced layers where each layer is itself a Lua expression that returns the decoded inner text.
  // So simplest final wrapper: assign the outermost expression to s, then iteratively loadstring and run.
  // We'll build final output as one function that runs the sequence.

  // To match IronBrew-style messy one-liner, we'll create a function that:
  //  - defines a small helper to run loadstring if present
  //  - assigns S0 = <outermost expression> (this returns inner-layer-lua text)
  //  - then iteratively do loadstring(S0)() if loadstring returns a function, until we reach original
  // But since our layer expressions already return strings, we can simply evaluate from outermost down by calling loadstring repeatedly.

  // Build final runner Lua
  const helperName = rndId(6);
  const runFunName = rndId(6);
  // We will place some junk blocks between declarations
  let finalLuaLines = [];
  finalLuaLines.push(`--[[obfed by Diamond obfuscator - ironbrew style]]`);
  finalLuaLines.push(`(function()`); // start wrapper to avoid polluting global
  // optional junk
  for(let j=0;j<Math.min(3, layers); j++) finalLuaLines.push(makeJunkBlock());
  // set outermost as s
  finalLuaLines.push(`local ${helperName} = ${current}`); // current is a Lua expression returning string
  // add loop to decode layers: call loadstring repeatedly layers times
  finalLuaLines.push(`local function ${runFunName}(s)`);
  finalLuaLines.push(`  local ok, f = pcall(loadstring, s)`);
  finalLuaLines.push(`  if ok and type(f) == "function" then`);
  finalLuaLines.push(`    local suc, res = pcall(f)`);
  finalLuaLines.push(`    if suc then return res end`);
  finalLuaLines.push(`  end`);
  finalLuaLines.push(`  return nil`);
  finalLuaLines.push(`end`);
  // Now perform iterative unwrapping. Because each layer returns the inner Lua as a string,
  // we need to call loadstring on the outermost string and evaluate to get the next string, and so on.
  // We'll do a simple loop with a safety iteration cap equal to layers+2.
  finalLuaLines.push(`local __s = ${helperName}`);
  finalLuaLines.push(`for _i=1,${layers+2} do`);
  finalLuaLines.push(`  local ok, f = pcall(loadstring, __s)`);
  finalLuaLines.push(`  if not ok then break end`);
  finalLuaLines.push(`  if type(f) ~= "function" then break end`);
  finalLuaLines.push(`  local suc, res = pcall(f)`);
  finalLuaLines.push(`  if not suc then break end`);
  finalLuaLines.push(`  if type(res) == "string" then __s = res else break end`);
  finalLuaLines.push(`end`);
  // After unwrapping, __s should be the decoded original script string in most cases.
  // Try executing it if it's loadable
  finalLuaLines.push(`local ok2, f2 = pcall(loadstring, __s)`);
  finalLuaLines.push(`if ok2 and type(f2) == "function" then pcall(f2) end`);
  finalLuaLines.push(`end)()`); // end wrapper and call

  let finalText = finalLuaLines.join("\n");

  if(oneLine){
    finalText = finalText.replace(/\s+/g," ").trim();
  }
  return finalText;
}

/* ---------- UI wiring ---------- */
const inputArea = document.getElementById("inputArea");
const outArea = document.getElementById("outArea");
const obfBtn = document.getElementById("obfBtn");
const copyBtn = document.getElementById("copyBtn");
const dlBtn = document.getElementById("downloadBtn");
const exampleBtn = document.getElementById("exampleBtn");

obfBtn.addEventListener("click", ()=>{
  const src = inputArea.value || "";
  if(!src.trim()){ alert("Paste some Luau code first!"); return; }
  const layers = parseInt(document.getElementById("layerCount").value,10) || 3;
  const oneLine = document.getElementById("oneLineChk").checked;
  const compactInner = document.getElementById("compactInner").checked;
  // generate
  try{
    const out = generateObfuscated(src, layers, oneLine, compactInner);
    outArea.textContent = out;
  }catch(e){
    outArea.textContent = "-- error generating obfuscation: " + (e && e.message ? e.message : String(e));
  }
});

exampleBtn.addEventListener("click", ()=>{
  inputArea.value = `-- example script
for i=1,3 do
  print("diamond", i)
end`;
});

copyBtn.addEventListener("click", ()=>{
  if(!outArea.textContent) return alert("Nothing to copy");
  navigator.clipboard.writeText(outArea.textContent).then(()=>{
    alert("Copied to clipboard");
  }, (err)=>{ alert("Copy failed: "+err); });
});

dlBtn.addEventListener("click", ()=>{
  if(!outArea.textContent) return alert("Nothing to download");
  const name = `diamond_obf_${Date.now()}.lua`;
  const blob = new Blob([outArea.textContent], {type:"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 5000);
});

/* Quick sanity check: verify syntax by trying to parse loadstring on a simple inner decode result.
   This only checks that the generated output contains loadstring calls and isn't completely invalid JS side.
*/
document.getElementById("verifyBtn").addEventListener("click", ()=>{
  const s = outArea.textContent;
  if(!s) return alert("No output to verify");
  // Basic checks
  if(!s.includes("loadstring") || !s.includes("bit32.bxor")) return alert("Output missing required primitives (loadstring/bit32.bxor) — likely invalid");
  alert("Basic check passed: output contains loadstring and bit32.bxor. Final runtime verification must be done in Roblox environment.");
});
</script>
</body>
  </html>
